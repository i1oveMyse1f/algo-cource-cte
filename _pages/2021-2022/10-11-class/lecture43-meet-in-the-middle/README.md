---
layout: lecture
title:  "Meet-in-the-middle"
author: i_love_myself
categories: [algo]
toc: true
---

## Четверка с суммой ноль

> В массиве размера $n$ ($n \leq 2000$) необходимо найти четыре числа, сумма которых равна $0$ (числа могут быть использованы несколько раз).

<details markdown="1" style="margin-bottom: 5%"><summary>Решение</summary>

Четыре числа $a, b, c, d$ с суммой $0$ прекрасно деляется на две части: $a+b = -(c+d)$. То есть если мы зафиксировали сумму первых двух чисел, то мы знаем, какой должна быть сумма вторых двух чисел. Это позволяет решить задачу за $O(n^2 \log n)$:

1. Сохраним суммы всех пар во множестве за $O(n^2 \log n)$
2. Переберем все пары ещё раз и проверим, есть ли пара чисел с противоположной суммой. Этот шаг тоже работает за $O(n^2 \log n)$

</details>

## Количество возрастающих последовательностей длины 3

> Дана последовательность $a_1, a_2, \ldots, a_n$. Найдите количество возрастающих последовательностей длины $3$.

<details markdown="1" style="margin-bottom: 5%"><summary>Решение для $n \leq 2000$</summary>
Будем перебирать центральный элемент в последовательности. Тогда пусть центральный элемент равен $a_i$, сколько последовательностей с таким элементов в середине есть? То есть нужно найти количество пар $(j, k)$: $j < i < k$ и $a_j < a_i \leq a_k$. Но по сути задачи для $j$ и $k$ не зависят друг от друга, поэтому можно независимо перебрать количество подходящих $j$ и $k$ суммарно за $O(n)$.
</details>

Бонус: решите задачу при ограничениях $n \leq 10^5$.

Часто подобная техника применяется и в задачах с полным перебором. Рассмотрим какую-нибудь задачу на перебор подмножеств, которую мы умеем решать за $O(2^n \cdot poly(n))$, где $poly(n)$ — какой-то полином от размера задачи $n$. Метод *meet-in-the-middle* (дословно, «встреча в середине») позволяет соптимизировать перебор до $O(2^{n/2} \cdot poly(n))$ в большом классе таких задач.

## Задача о рюкзаке

> Рассмотрим задачу о рюкзаке — нужно выбрать подмножество $a_i$ с суммарным весом $w$, однако в нашей задаче веса предметов могут быть большими: $1 \leq a_i \leq 10^9$.

<details markdown="1" style="margin-bottom: 5%"><summary>Решение для $n \leq 25$</summary>

Тогда перебор всех подмножеств можно осуществить следующим образом:

```cpp
bool find_subset(int *a, int n, int w)
    for (int mask = 0; mask < (1 << n); mask++) {
        int s = 0;
        for (int i = 0; i < n; i++)
            if (mask >> i & 1)
                s += a[i];
        if (s == w)
            return true;
    }
    return false;
}
```

Здесь мы перебираем все подмножества и каждое проверяем за $O(n)$, что дает асимптотику $O(2^n \cdot n)$.

В теории можно избавиться от проверки за $O(n)$, если перебирать маску рекурсивно и поддерживать текущую сумму на префиксе, возможно добавляя во время спуска только один элемент. Однако мы погонимся за более мощной оптимизацией.

</details>

<details markdown="1" style="margin-bottom: 5%"><summary>Решение для $n \leq 50$</summary>

Разделим массив на две части. Заметим, что искомое подмножество имеет какое-то количество элементов из левой половины и какое-то количество элементов из правой (возможно, нулевое). Попытаемся посчитать все суммы слева и справа по отдельности и найти пару, дающую нужную общую сумму.

Сначала посчитаем суммы для всех подмножеств среди первых $l = \lfloor \frac{n}{2} \rfloor$ элементов и положим в хеш-таблицу:

```cpp
unordered_set<int> t;

int l = n / 2;

for (int mask = 0; mask < (1 << l); mask++) {
    int s = 0;
    for (int i = 0; i < n; i++)
        if (mask >> i & 1)
            s += a[i];
    t.insert(s);
}
```

Затем переберем все суммы среди оставшихся $r = n - l = \lceil \frac{n}{2} \rceil$ элементов и для каждой попытаемся найти подходящую половину (с суммой $s_l = w - s_r$) через предподсчитанную хеш-таблицу:

```cpp
int r = n - l;

for (int mask = 0; mask < (1 << r); mask++) {
    int s = 0;
    for (int i = 0; i < r; i++)
        if (mask >> i & 1)
            s += a[l + i];
    if (t.count(w - s))
        return true;
}
```

Обе фазы (а значит и сам алгоритм) работают за $O(2^{n/2} \cdot n)$: мы перебираем $2^{n/2}$ подмножеств и для каждого за $O(n)$ считаем сумму и делаем запрос добавления / проверки наличия в хеш-таблицу за $O(1)$.

Заметим, что оба перебора всё ещё можно так же соптимизировать в $O(n)$ раз через трюк с рекурсией.

</details>

## Модификации рюкзака

> Можно ли разделить предметы на четыре кучки равного веса за $O(n2^n)$?

> Можно ли разделить предметы на $k$ кучек равного веса за $O(n2^n)$?

## Количество клик

> Дан граф из $n$ $(n \leq 40)$ вершин. Нужно найти количество *клик* — подграфов, в котором все вершины связаны со всеми.

![Клика](./img/cliques.png)

<details markdown="1" style="margin-bottom: 5%"><summary>Решение</summary>

Сначала научимся решать задачу полным перебором. Пусть у нас есть матрица смежности графа. Как быстро проверить, что подмножество вершин $m$ является кликой?

За $O(n^2)$ можно пройтись по всем парам включенных вершин и для каждой проверить, есть ли единичка в матрице смежности. Проверку можно соптимизировать до $O(n)$, посчитав маску $m'$, равную побитовому «И» строчек матрицы смежности, соответствующих вершинам $m$. Теперь, если $m$ является подмножеством $m'$, то есть

$$
m \; \& \; m' = m
$$

то подграф $m$ является кликой: для всех его вершин есть ребро из всех других.

Воспользуемся этим трюком для слияния ответов в meet-in-the-middle. Разделим граф на две части, найдем для левой все клики и пометим их маски единицами в специальном массиве `is_clique[mask]` размера $2^{n/2}$.

Теперь будем перебирать подграфы второй половины, и для каждой клики нам нужно найти количество клик левой половины, являющихся подграфами пересечения списков смежности для правой половины ($m'$ из проверки выше).

Чтобы сделать это быстро, предподсчитаем поверх массива `is_clique` динамику «как много подмасок данной маски являются кликами». Эту динамику можно посчитать за $O(2^{n/2})$, если для каждой маски $m$ рассмотреть два варианта — когда первая вершина $v$ включена в клику и когда не включена:

$$
f[m] = f[m \; \& \; g_v \oplus 2^v] + f[m \oplus 2^v] + is\_clique[m]
$$

Итоговая асимптотика алгоритма будет $O(2^{n/2} \cdot n)$.

</details>

## Взломай хеш

> Найдите строку $s$ с полиномиальным хешом, равным $X$, где основание хеша равно $M$ ($M \leq 10^9$). Напомним, что полиномиальных хеш вычисляется по формуле:
> $$ h(s_1s_2\ldots s_n) = (s_1 + 26 \cdot s_2 + 26^2 \cdot s_3 + \ldots + 26^{n-1}\cdot s_n) \% M $$

<details markdown="1" style="margin-bottom: 5%"><summary>Решение</summary>
Соберем случайные $10^6$ строк которкой длины. Все их хеши - случайные числа. Конечно, вероятность попасть так в нужный хеш стремится к нулю, поэтому трюк:

Искомая строка будет иметь вид $t_i + t_j$, где $t_i, t_j$ из нашего множества строк. И вот теперь то мы уже с вероятностью 1 соберем нужных хеш. Почему? Потому что пар $t_i+t_j$ порядка $10^12$, то есть количество строк увеличилось в квадрат раз. А вероятность того, что мы не попали этими $10^12$ строками в нужный $X$ стремится к нулю.

Такое решение работает за $O(10^6 \log 10^6)$, потому что если зафиксировать $t_i$, то мы знаем, чем должен быть равен хеш $t_j$, то есть явно перебирать все пары нам не надо - надо лишь проверить наличие строки с заданным хешом во множестве.
</details>

## Ссылки

1. [neerc](https://neerc.ifmo.ru/wiki/index.php?title=Meet-in-the-middle)
1. [algorithmica](https://ru.algorithmica.org/cs/decomposition/mitm/)
1. [cf Errichto blog](https://codeforces.com/blog/entry/95571)
