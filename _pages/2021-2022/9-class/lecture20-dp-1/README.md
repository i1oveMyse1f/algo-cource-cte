---
layout: lecture
title:  "Линейная и не очень динамика"
author: i_love_myself
categories: [ dp ]
toc: true
---

## Что такое динамическое программирование?

Динамическое программирование в теории управления и теории вычислительных систем — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

Звучит сложно. Давайте на примерах.

## Кузнечик

> Есть полоска из клеток длины n. Кузнечик находится в клетке номер 1 и хочет попасть в клетку номер n. Каждый раз кузнечик может прыгать лишь вперёд на расстояние от 1 до 3. Сколько различных маршрутов существует у кузнечика?

<details markdown="1">
  <summary>Очень подробное решение</summary>
  
  Если подходить к задаче в лоб с помощью перебора, то всё выглядит очень грустно. Да и работать будет долго. Разобьем задачу на более простые подзадачи:

  Пусть ```dp[k]``` - ответ на задачу, если полоска была длины k. Будем называть это _состоянием динамики_.Предположим, мы умеем вычислять dp для всех k от 1 до n-1. Как же вычислить ```dp[n]```? В клетку номер n кузнечик мог попасть лишь из трёх: n-1, n-2, n-3. При этом все три типа маршрута будут разными. Поэтому количество маршрутов до клетки n можно вычислить по _рекурсивной формуле_:

  <p align="center">dp[n] = dp[n - 1] + dp[n - 2] + dp[n - 2] </p>
  
  Это замечательно, мы почти решили задачу! Осталось обговорить пару моментов, а именно: _базу динамики_ и _порядок обхода_.
  
  База динамики, либо начальное состояние динамики - это то состояние, от которого можно оттолкнуться при вычислении рекурсивной формулы. Например, в нашем случае это будет ```dp[1] = 1```. Все остальные значения можно вычислить по рекурсивной формуле в порядке увеличения n.
</details>

<details markdown="1">
  <summary>Код</summary>
  
```cpp
int main() {
    int n;
    cin >> n;
    vector<int> dp(n);
    dp[0] = 1;
    for (int i = 1; i < n; ++i) {
      dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }
    cout << dp[n - 1];
}
```
</details>

На примере выше мы разобрались, что для решения задачи на ДП нужно 4 вещи:

1. Состояние динамики. В примере выше состояние было очень простым: dp[k] - ответ на задчу, если бы полоска была длины k.
2. Переходы динамики. В примере выше это рекурсивный переход dp[k] = dp[k - 1] + dp[k - 2] + dp[k - 3].
3. Начальное состояние. В примере выше это dp[1] = 1.
4. Порядок обхода. В нашем случае это порядок по возрастанию n.

## Кузнечик на максималках

Усложним предыдущую задачу, сохранив при этом асимптотику решения, то есть хочется получить решение за O(n).

> Есть полоска из клеток длины n. Неоторые клетки недоступны. Кузнечик находится в клетке номер 1 и хочет попасть в клетку номер n. Каждый раз кузнечик может прыгать лишь вперёд на расстояние от 1 до k. Сколько различных маршрутов существует у кузнечика?

<details markdown="1">
  <summary>Решение за квадрат</summary>
  
  Решение будет очень похожим. Для начала попробуем решить ровно так же как и прошлую задачу:

  Пусть dp[m] - ответ на задачу, если бы полоска была длины m. Тогда переходы для доступных будут иметь вид:

  <center>dp[m] = dp[m - 1] + dp[m - 2] + ... + dp[m - k]</center>

  Если клетка недоступна, то dp[m] = 0.

  К сожалению, мы решили задачу за O(n * k), что в худшем случае ведёт себя как квадрат. Но рано отчаиваться, решение можно улучшить!
</details>

<details markdown="1">
  <summary>Решение за линию</summary>
  
  Будем хранить pref[k] = dp[k] + dp[k - 1] + ... + dp[1]. Это называется префиксной суммой на масиве динамики. И префиксные суммы прекрасно помогают соптимизировать динамику:

  <center>dp[m] = dp[m - 1] + dp[m - 2] + ... + dp[m - k] = pref[m - 1] - pref[m - k - 1]</center>

  То есть достаточно лишь одной операции разности на массиве префиксных сумм, которые очень лекго поддерживать при нашем подсчёте динамики.
</details>

Из этой задачи стоит понять, что иногда можно ускорить вашу динамику с помощью разных интересных техник. Эти техники приходят лишь с опытом, так что стоит решать как можно больше задач на ДП.

## Самая длинная подпоследовательность (из контеста по ТЧ)

> Вам задан массив a из n элементов и число m. Рассмотрим некоторую подпоследовательность a и значение наименьшего общего кратного (НОК) её элементов. Обозначим этот НОК буквой l. Найдите самую длинную подпоследовательность массива a со значением l ≤ m.

<details markdown="1">
  <summary>Решение</summary>
  
  Задача очень сложная. Необходимо додуматься до нескольких идей.

  Идея 1. Задача так сформулирована, что вы начинаете думать о подпоследовательности, а нужно на самом деле по сути искать подмножество, так как порядок для взятия НОКа не важен.

  Идея 2. Разобьем числа на группы раных элементов. Пусть чисел, равных x в точности cnt[x]. Не сложно заметить, что если мы взяли число x, то можно взять все cnt[x] чисел, что только увличит размер подмножества.

  Идея 3. Пусь dp[i][j] - это максимальное количество чисел, если НОД равен i и мы рассмотрели первые j групп чисел.

  Иедя 4. Переходы. Если t=x*i - НОД чисел, то мы можем взять группу чисел i. То есть dp[x*i][j + 1] = dp[x*i][j] + cnt[x], где текущая группа состоит из чисел, равных x, а i - любое число.

  Идея 5. Можно считать dp в одном и том же массиве (не двумерном, а одномерном).

  Идея 6. Решение работает за O(n log n).
</details>

## НОП

> Даны две последовательности a и b. Необходимо найти наибольшую подпоследовательность, которая содержится в каждой из последовательснотей a и b.

<details markdown="1">
  <summary>Решение за квадрат</summary>
  
  Пусть состояние динамики dp[i][j] - это размер НОП, если бы a состояло из префикса размера i, а b - из префикса размера j.

  Не сложно понять, что бывает 2 вида переходов:

  Если a[i] = b[j], то можно удлинить посдедовательность dp[i-1][j-1] числами a[i] и b[j]. В противном случае нужно взять "лучший ответ", который лежит либо в dp[i-1][j], либо в dp[i][j - 1].

  Базу динамики и порядок обхода остаётся на вас.
</details>

## Расстояние Левенштейна

> Определите минимальное количество односимвольных операций (а именно вставки, удаления, замены), необходимых для превращения одной последовательности символов в другую.

<details markdown="1">
  <summary>Решение за квадрат</summary>
  
  [тык на foxford](https://foxford.ru/wiki/informatika/vychislenie-rasstoyaniya-levenshteyna)
</details>

## НВП

> Дана последовательность a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>. Необходимо найти такую подпоследовательность в ней, что все элементы идут строго по возрастанию.

<details markdown="1">
  <summary>Решение</summary>
  
  [Очень советую прочитать всё об НВП на e-maxx.](https://e-maxx.ru/algo/longest_increasing_subseq_log)
</details>

<details markdown="1">
<summary> Код с восстановлением ответа </summary>

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

const int INF = 2e9;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int& x : a)
        cin >> x;

    vector<int> p(n, -1);
    vector<int> dp(n + 1, INF);
    vector<int> ind_dp(n + 1, -1);
    dp[0] = -INF;

    for (int i = 0; i < n; ++i) {
        int l = 0, r = n + 1;
        // dp[l]: dp[l] < a[i] и l - max

        while (r - l > 1) { // [l; r)
            int m = (r + l) / 2;
            if (dp[m] < a[i])
                l = m;
            else
                r = m;
        }

        dp[l + 1] = a[i];
        ind_dp[l + 1] = i;
        p[i] = ind_dp[l];
    }

    int i = 1;
    while (i < n && dp[i + 1] != INF)
        ++i;

    i = ind_dp[i]; // индекс ( из a) последнего элемента самой длинной ВП
    vector<int> ans;
    ans.push_back(a[i]);
    while (p[i] != -1) {
        i = p[i];
        ans.push_back(a[i]);
    }

    reverse(ans.begin(), ans.end());
    for (int x : ans)
        cout << x << ' ';
}
```

</details>

## Рюкзак

> Дано N предметов, n<sub>i</sub> предмет имеет массу w<sub>i</sub> > 0 и стоимость p<sub>i</sub> > 0. Необходимо выбрать из этих предметов такой набор, чтобы суммарная масса не превосходила заданной величины W (вместимость рюкзака), а суммарная стоимость была максимальна.

<details markdown="1">
  <summary>Решение</summary>
  
  [Очень советую прочитать все модификации задачи о рюкзаке](https://neerc.ifmo.ru/wiki/index.php?title=%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5)
</details>
