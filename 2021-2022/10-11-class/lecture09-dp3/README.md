# ДП по подмножествам и цифрам. Разбор задач

## Задача (скука)

> Задана последовательность a, состоящая из n целых чисел. Игрок может сделать несколько ходов. За один ход игрок может выбрать некоторый элемент последовательности (обозначим выбранный элемент a<sub>k</sub>) и удалить его, при этом из последователости также удаляются все элементы, равные a<sub>k+1</sub> и a<sub>k - 1</sub>. Описанный ход приносит игроку a<sub>k</sub> очков. Какое максимальное количество очков возможно набрать?

#### Решение

Обозначим за cnt[x] количество элементов, равных x. Заметим, что если мы хотя бы раз выбрали элемент, равный x, то мы можем выбрать все cnt[x] элементов, равных x.

Далее пусть dp[x] - максимальное количество очков, которое можно набрать, если бы в массиве были элементы, не превосходящие x. Тогда переходы динамики очень простые:

<p align="center"> dp[i] = max(dp[i - 1], dp[i - 2] + cnt[i] * i) </p>

То есть мы либо берем все числа, равные i и тогда не можем взять числа, равные i-1, либо берем оптимальный ответ для i-1, не взяв при этом i числа, равные i.

#### Код

```cpp
// code will be here
```

## Задача (гирьки: две одинаковые кучки равной массы)

> Дан набор гирек массой m<sub>1</sub>,…,m<sub>N</sub>. Разделите этот набор на две кучки равной массы, содержащие равное число гирек.

### Решение

Здесь нужно совсем чуть-чуть модифицировать рюкзак, а именно: пусть dp[i][w][k] - обозначает, можем ли мы набрать среди первых i гирек рюкзак массой w, содержащий k гирек. Переходы будут иметь вид: (i, w, k) -> (i + 1, w, k) и (i + 1, w + weight[i], k + 1). Ответ будет лежать в dp[n][w/2][k/2].

### Код

```cpp
// code will be here
```

## Задача (максимальное число)

> Найдите число из отрезка [a, b] с максимальным произведением цифр.

Часто нужно перебрать все числа из какого-то большого интервала и посчитать количество чисел, котрое удовлетворяет какому-то условию, либо найти "лучшее" среди чисел в этом интервале. Тогда нам поможет стандартное ДП по цифрам.

### Решение

Пусть dp[l][f1][f2] - это максимальное произведение цифр для числа длины ровно l. При этом если f1 = 0, то "оптимальное" число длины l строго меньше префикса длины l числа a, если f1 = 1, то префиксы совпадают и если f1 = 2, то префикс строго больше. Аналогично для f2 и числа b.

Зачем такие извращения? Потому что по такому состоянию очень легко узнать, находится ли число в интервале [a; b] или нет. Кроме того, переходы тоже очень легко считаются: если f1 = 0, то переход вохможен только в состояния с f1 = 0 (то же самое для f1 = 2 и для f2). Если же f1 = 1, то вы можете перейти в любое состояние в зависимости от очередной цифры, которую вы сейчас поставите.

### Код

```cpp
// code will be here
```

## Задача (Настя и табло)

> На табло с цифрами перестало гореть k "палочек". По текущей конфигерации табло и числу k необходимо понять, какое максимальное число может гореть на табло, если включить ровно k палочек (из тех которые сейчас выключены)?

### Решение

Пусть dp[i][j]=true, если на суффиксе i…n можно включить ровно j палочек и получить корректную последовательность цифр и false иначе. Такую динамику легко пересчитать: будем делать переходы во все возможные цифры, которые являются надмаскми нашей маски на позиции i.

Построение динамики занимает O(10nd).

Теперь пойдём в порядке от 1 до n и будем пробовать жадно ставить максимально возможную цифру, используя нашу динамику. Легко понять, что таким образом мы получим максимально возможное число из n цифр.

### Код

```cpp
// code will be here
```

### Бонус

На самом деле здесь мы неявно познакомились с техникой ДП по подмножествам, когда нам прилось как-то кодировать "палочки". Эта техника очень часто помогает в задачах на ДП, когда необходимо перебрать все подмножества.
