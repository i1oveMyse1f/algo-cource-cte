# ДП по подотрезкам

Тема не должна быть сложной. Главная идея - это хранить оптимальный ответ на подотрезке l...r, поэтому состояние будет dp[l][r] (и, возможно, ещё что-то) и обходить в порядке увеличения длины отрезка. Разберём несколько задач:

## Получи ПСП

> Дана последовательсность из скобок длины n. Необходимо удалить как можно меньше скобок так, чтобы получилась правильная скобочная последовательность.

<details>
<summary>Решение</summary>

Для начала, стоит сразу понять, что это задача на дп по подотрекам. Это значит, что бы будем вычислять dp[l][r] - оптимальный ответ на задачу на подотрезке строки l..r. Более детально:

Пусть dp[l][r] - это какой максимальной длины может быть ПСП на подотрезке l...r.

Определение ПСП подсказывает нам, какие же переходы возможны:

1. По второму пункту определения, если s[l] = s[r], то мы можем перейти к состоянию dp[l+1][r-1] + 2.
1. По третьему пнутку определения, мы можем разбить отрезок l...r на два независимых подотрезка l...m и m+1...r, то есть dp[l][m] + dp[m+1][r].

Среди всех возможных переходов нужно взять максимум.

</details>

<details>
<summary> Код </summary>

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

bool is_match(char a, char b) {
    return a == '(' && b == ')' || a == '[' && b == ']';
}

int main() {
    string s;
    cin >> s;
    int n = s.size();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    // ()[]

    for (int len = 1; len <= n; ++len) {
        for (int i = 0, j = len - 1; j < n; ++i, ++j) {
            if (len == 1) {
                dp[i][j] = 0;
            }
            else if (len == 2) {
                if (is_match(s[i], s[j])) {
                    dp[i][j] = 2;
                }
                else {
                    dp[i][j] = 0;
                }
            }
            else {
                dp[i][j] = 0;
                if (is_match(s[i], s[j]))
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                for (int m = i + 1; m <= j - 1; ++m)
                    dp[i][j] = max(dp[i][j], dp[i][m] + dp[m + 1][j]);
            }
        }
    }

    cout << dp[0][n - 1];
}
```

</details>

## Количество бинарных деревьев поиска

> Дан набор целых чисел a длины n. Необходимо вычислить, какое количество различных бинарных деревьев поиска можно построить, используя все числа из набора. <br> Напомню, что _бинарным деревом поиска_ может называеться дерево, у которого удовлетворяющее двум ограничениям: <br> 1. У каждой вершины не больше двух детей <br> 2. Если в вершине стоит число x, то в левом поддереве все числа должны быть строго меньше x, а в правом - не меньше x.

<details>
<summary> Решение </summary>

Идея 1. Нужно отсортировать массив a. По правилам бинарного дерева поиска если есть вершина, то слева от неё все элементы должны быть строго меньше x, а справа - не меньше, поэтому мы не можем расставлять значения в другом порядке.

Идея 2. Применить дп по подотрезкам. Пусть dp[l][r] - количество бинарных деревьев поиска, которое мы можем построить на подотрзке l...r. Как его вычислить? Необходимо выбрать корень - m-тый элемент, а далее обратиться к dp[l][m-1] и dp[m+1][r], перемножив два этих числа (так как мы можем независимо выбрать любое поддерво слева и любое поддерево справа). Таким образом, переходы динамики выглядят так:

<p align="center">
dp[l][r] = sum(dp[l][m - 1] * dp[m + 1][r])
</p>

При этом оставим вам на подумать, какие m можно выбрать (не все).

</details>

<details>
<summary> Код </summary>
Haha. Classic.
</details>