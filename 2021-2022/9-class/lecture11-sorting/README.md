# Сортировки

## Сортировка вставкой [Insert sort]

Это одна из самых простых сортировок, которые можно придумать. Разберём сортировку на примере: пусть дан массив [2, 1, 10, 5]. Отсортируем его за 4 шага, для этого на каждом шаге будем смотреть лишь на первые несколько элементов массива. На первом шаге - только на первый, на втором - только на первый и второй и т.д.

* [2] - отсортированный массив
* к массиву [2] добавляется 1, после сортировки становится [1, 2]
* к массиву [1, 2] добавляется 10, после сортировки становится [1, 2, 10]
* к массиву [1, 2, 10] добавляется 5. После сортировки становится [1, 2, 5, 10]

Теперь должно стать понятно, почему сортировка называется "сортировка вставкой". На каждой итерации, чтобы отсортировать массив, нам необходимо лишь вставить его в нужное место. Например, на последней итерации мы вставили 5 между 2 и 10, чтобы массив вновь стал отсортированным.

Реализуем эту сортировку на C++:

```cpp
void sort(vector<int>& a) {
    for (int i = 1; i < a.size(); ++i) { // цикл по всем итерациям; первую можно пропустить
        for (int j = i; j > 0 && a[j] < a[j - 1]; --j) { // вставляем a[i] на нужную позицию
            swap(a[j], a[j - 1]);
        }
    }
    return a;
}
```

Прокомментирую внутренний цикл. Он сдвигает элемент, если он идёт "не в правильном порядке". Например, у нас массив из [1, 5, 10, 4] и сейчас мы должны вставить 4 на нужную позицию, тогда будем постепенно её сдвигать влево, пока не окажется ситуации 1 < 4 < 5.

Добавим сюда визуализацию:
![Insert sort](./img/insert_sort.gif)

К сожалению, наша сортировка работает за O(n<sup>2</sup>). Сегодня мы рассмотрим более крутые сортировки!

## Пузырьковая сортировка [Bubble sort]

Это вторая наша сортировка, и она тоже будет работать за O(n<sup>2</sup>). Однако, оказалось, что на практике она ведёт себя весьма неплохо (но, конечно, не применима в олимпиадном программировании).

Мы опять будем сортировать массив "потихоньку". И на самом деле вы увидите гигантское сходство с сортировкой вставкой. На каждой итерации мы опять будем требовать, чтобы был отсортирован некоторый префикс нашего массива, но теперь мы сделаем трюк: если мы видим, что пара элементов стоят не в правильном порядке (то есть a[j - 1] > a[j]), то поменяем их местами и будем делать так НА ВСЁМ массиве. То есть от сортировки вставкой есть лишь одно отличие: на каждой итерации мы проходимся по всему массиву.

```cpp
void sort(vector<int>& a) {
    for (int i = 1; i < a.size(); ++i) {
        for (int j = n - 1; j > 0; --j) {
            if (a[j] < a[j - 1])
                swap(a[j], a[j - 1]);
        }
    }
}
```

На практике (если такая фраза применима к сортировкам) люди обрывают итерации как только внутренний цикл не сделал ни одного swap.

Добавим визуализацию работы пузырьковой сортировки (здесь всё работает в другом порядке: вместо того, чтобы проталкивать минимум, как в реализации выше, проталкивается максимум).

![Bubble sort](./img/bubble_sort.gif)

Если хотите посмотреть, как работает пузырьковая сортировка на примере танца (вдруг), то [Bubble-sort with Hungarian](https://youtu.be/lyZQPjUT5B48) вам поможет.

## Сортировка слиянием [Merge sort]

А вот и золото нашей сегодняшней программы - сортировка слиянием. Позволяет сортировать массив за O(n log n). К тому же, сортировка очень простая и легко интерпретируемая (в отличии от быстрой сортировки из следующего раздела).

### Merge

Для начала разберем простой вспомогательный алгоритм, который назовём merge. Он принимает два ОТСОРТИРОВАННЫХ массива и выдает отсортированный массив, состоящий из всех элементов обоих массивов. При этом, делает это крайне быстро. Работу функции лучше всего описать гифкой:

![Merge function](./img/merge_func.gif)

Прокомментирую: нам необходимо поддерживать два указателя (указатель на текущий элемент в первом массиве и во втором). Далее, сравнивать два текущих элемента и выписывать меньший из них. После - нужно сдвинуть указатель.

```cpp
vector<int> merge(const vector<int>& a, const vector<int>& b) {
    int n = a.size(), m = b.size();
    vector<int> res(n + m);
    for (int i = 0, j = 0; i < n && j < m; ) {
        if (i < n && j < m && a[i] < b[j] || j == m) {
            res[i + j] = a[i];
            ++i;
        } else {
            res[i + j] = b[j];
            ++j;
        }
    }
    return c;
}
```

Небольшой комментарий: конечно же, мы должны сравнивать a[i] и b[j] только в том случае, когда мы не вышли за границы массива. А если вышли за границы одного из них, то нужно выписывать элементы из другого массива (для этого проверяется j == m).

### Merge sort

Теперь воспользуемся техникой Divide and Conqueror. Что же мы будем разделять и как нам над этим властвовать?

* Divide. Разделим массив на две равные части. Отсортируем каждую из частей по-отдельности рекурсивно
* Conqueror. Теперь, когда каждая из частей массива отсортированная, мы можем их склеить с помощью функции merge.

Картинка для наглядности и оценки времени алгоритма:

![Merge sort](./img/merge_sort.jpg)

Напишем код и воспользуемся встроенной функцией merge:

```cpp
void sort(vector<int>& a, int l, int r) { // сортируем интервал [l; r)
    if (r - l == 1) {
        return; // массив из одного элемента отсортирован
    } else {
        int m = (r + l) / 2;
        sort(a, l, m);
        sort(a, m, r);
        vector<int> res(r - l);
        merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, res.begin());
        copy(res.begin(), res.end(), a.begin() + l);
    }
}
```

В очередной раз прокомментирую реализацию: встроенная функция merge принимает итераторы на начало и конец первого массива, итераторы на начало и конец второго массива и итератор на начало места, куда положить результата merge.

**Очень важно.** Вы не можете класть результат сразу в a.begin() + l. В этом случае вы можете затереть значения левого массива! Поэтому я создаю временный массив и только потом из него копирую элементы в исходный.

И последнее, можно заметить, что сортировка делает O(n log n) операций сравнения, потому что всего есть log n уровней (смотри картинку выше), суммарное время работы сортировки на каждом уровне - O(n). Значит сортировка работает за O(n log n).

Добавим сюда визуализацию кода, написанного выше:

![Merge sort](./img/merge_sort.gif)

### Количество инверсий

> Инверсией в массиве называется пара (i, j), для которых верно, что i <  j и a[i] > a[j]. Посчитайте количество инверсий за O(n log n).

## Быстрая сортировка [Quick sort]

Быстрая сортировка очень похожа на merge sort, но в ней есть одно ключевое отличие: она недетерминированная, то есть в ней присутствует элемент случайности.

Сортировка будет состоять из нескольких итераций:

1. Выбор опорного элемента (pivot) - он производится случайно.
1. Вызываем функцию partition, которая сортирует всё относительно опорного элемента. То есть все элементы, меньшие pivot, оказываются левее него, а большие - правее.
1. Рекурсивно запускаем сортировку для левой и правой частей массива.

Функция partition будет проходиться по массиву ровно один раз с помощью двух указателей - левый и правый, которые изначально стоят в самом левом и самом правом элементе массива. Если так оказывается, что левый элемент больше pivot, а правый - меньше, то меняем их местами. Иначе двигаем один из указателей (тот, который ок, то есть если левый элемент меньше pivot, то он ок и двигаем его, аналогично с правым).

Добавим сюда визуализацию:

![Quick sort](./img/quick_sort.gif)

Если хотите посмотреть, как работает быстрая сортировка на примере танца (вдруг), то [Quick-sort with Hungarian](https://youtu.be/ywWBy6J5gz8) вам поможет.

Реализация приняла Ислам.

## Сортировка подсчётом [Count sort]

Одна из самых простых, но в то же время полезных сортировок. И её алгоритм настолько прост, на сколько это только возможно.

1. Посчитаем количество каждого элемента в массиве
2. Выпишем элементы в порядке возрастания в нужном количестве

Такая сортировка работает только для целых чисел и работает быстро, если по условию максимальное число в массиве (обозначим его за C) не очень большое (сопоставимо с количеством элементов в массиве). В таком случае сортировка будет работать за O(n + C).

Реализация так же проста до безобразия:

```cpp
void sort(vector<int>& a) {
    vector<int> cnt(1'000'000);
    for (int x : a) {
        cnt[x]++;
    }
    int ptr = 0;
    for (int c : cnt) { // пробегаемся по всем возможным значениям
        while (c--) { // выписываем их c раз
            a[ptr++] = c;
        }
    }
}
```

## По цифрам [Digit sort]

Одна из модификаций сортировка по цифрам - это скорее всего то, как ты сортируешь числа в голове.
