# Сортировки

## Сортировка вставкой [Insert sort]

Это одна из самых простых сортировок, которые можно придумать. Разберём сортировку на примере: пусть дан массив [2, 1, 10, 5]. Отсортируем его за 4 шага, для этого на каждом шаге будем смотреть лишь на первые несколько элементов массива. На первом шаге - только на первый, на втором - только на первый и второй и т.д.

* [2] - отсортированный массив
* к массиву [2] добавляется 1, после сортировки становится [1, 2]
* к массиву [1, 2] добавляется 10, после сортировки становится [1, 2, 10]
* к массиву [1, 2, 10] добавляется 5. После сортировки становится [1, 2, 5, 10]

Теперь должно стать понятно, почему сортировка называется "сортировка вставкой". На каждой итерации, чтобы отсортировать массив, нам необходимо лишь вставить его в нужное место. Например, на последней итерации мы вставили 5 между 2 и 10, чтобы массив вновь стал отсортированным.

Реализуем эту сортировку на C++:

```cpp
void sort(vector<int>& a) {
    for (int i = 1; i < a.size(); ++i) { // цикл по всем итерациям; первую можно пропустить
        for (int j = i; j > 0 && a[j] < a[j - 1]; --j) { // вставляем a[i] на нужную позицию
            swap(a[j], a[j - 1]);
        }
    }
    return a;
}
```

Прокомментирую внутренний цикл. Он сдвигает элемент, если он идёт "не в правильном порядке". Например, у нас массив из [1, 5, 10, 4] и сейчас мы должны вставить 4 на нужную позицию, тогда будем постепенно её сдвигать влево, пока не окажется ситуации 1 < 4 < 5.

Добавим сюда визуализацию:
![Insert sort](./img/insert_sort.gif)

К сожалению, наша сортировка работает за O(n<sup>2</sup>). Сегодня мы рассмотрим более крутые сортировки!

## Пузырьковая сортировка [Bubble sort]

Это вторая наша сортировка, и она тоже будет работать за O(n<sup>2</sup>). Однако, оказалось, что на практике она ведёт себя весьма неплохо (но, конечно, не применима в олимпиадном программировании).

Мы опять будем сортировать массив "потихоньку". И на самом деле вы увидите гигантское сходство с сортировкой вставкой. На каждой итерации мы опять будем требовать, чтобы был отсортирован некоторый префикс нашего массива, но теперь мы сделаем трюк: если мы видим, что пара элементов стоят не в правильном порядке (то есть a[j - 1] > a[j]), то поменяем их местами и будем делать так НА ВСЁМ массиве. То есть от сортировки вставкой есть лишь одно отличие: на каждой итерации мы проходимся по всему массиву.

```cpp
void sort(vector<int>& a) {
    for (int i = 1; i < a.size(); ++i) {
        for (int j = n - 1; j > 0; --j) {
            if (a[j] < a[j - 1])
                swap(a[j], a[j - 1]);
        }
    }
}
```

На практике (если такая фраза применима к сортировкам) люди обрывают итерации как только внутренний цикл не сделал ни одного swap.

Добавим визуализацию работы пузырьковой сортировки (здесь всё работает в другом порядке: вместо того, чтобы проталкивать минимум, как в реализации выше, проталкивается максимум).

![Bubble sort](./img/bubble_sort.gif)

Если хотите посмотреть, как работает пузырьковая сортировка на примере танца (вдруг), то [Bubble-sort with Hungarian](https://youtu.be/lyZQPjUT5B48) вам поможет.

## Сортировка слиянием [Merge sort]

А вот и золото нашей сегодняшней программы - сортировка слиянием. Позволяет сортировать массив за O(n log n). К тому же, сортировка очень простая и легко интерпретируемая (в отличии от быстрой сортировки из следующего раздела).

### Merge

Для начала разберем простой вспомогательный алгоритм, который назовём merge. Он принимает два ОТСОРТИРОВАННЫХ массива и выдает отсортированный массив, состоящий из всех элементов обоих массивов. При этом, делает это крайне быстро. Работу функции лучше всего описать гифкой:

![Merge function](./img/merge_func.gif)

Прокомментирую: нам необходимо поддерживать два указателя (указатель на текущий элемент в первом массиве и во втором). Далее, сравнивать два текущих элемента и выписывать меньший из них. После - нужно сдвинуть указатель.

```cpp
vector<int> merge(const vector<int>& a, const vector<int>& b) {
    int n = a.size(), m = b.size();
    vector<int> res(n + m);
    for (int i = 0, j = 0; i < n && j < m; ) {
        if (i < n && j < m && a[i] < b[j] || j == m) {
            res[i + j] = a[i];
            ++i;
        } else {
            res[i + j] = b[j];
            ++j;
        }
    }
    return c;
}
```

Небольшой комментарий: конечно же, мы должны сравнивать a[i] и b[j] только в том случае, когда мы не вышли за границы массива. А если вышли за границы одного из них, то нужно выписывать элементы из другого массива (для этого проверяется j == m).

### Merge sort

Теперь воспользуемся техникой Divide and Conqueror. Что же мы будем разделять и как нам над этим властвовать?

* Divide. Разделим массив на две равные части. Отсортируем каждую из частей по-отдельности рекурсивно
* Conqueror. Теперь, когда каждая из частей массива отсортированная, мы можем их склеить с помощью функции merge.

Картинка для наглядности и оценки времени алгоритма:

![Merge sort](./img/merge_sort.jpg)

Напишем код и воспользуемся встроенной функцией merge:

```cpp
void sort(vector<int>& a, int l, int r) { // сортируем интервал [l; r)
    if (r - l == 1) {
        return; // массив из одного элемента отсортирован
    } else {
        int m = (r + l) / 2;
        sort(a, l, m);
        sort(a, m, r);
        vector<int> res(r - l);
        merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, res.begin());
        copy(res.begin(), res.end(), a.begin() + l);
    }
}
```

В очередной раз прокомментирую реализацию: встроенная функция merge принимает итераторы на начало и конец первого массива, итераторы на начало и конец второго массива и итератор на начало места, куда положить результата merge.

<div class="alert alert-danger">
    Очень важно. Вы не можете класть результат сразу в a.begin() + l. В этом случае вы можете затереть значения левого массива! Поэтому я создаю временный массив и только потом из него копирую элементы в исходный.
</div>

Добавим сюда визуализацию кода, написанного выше:

![Merge sort](./img/merge_sort.gif)

### Количество инверсий

> Инверсией в массиве называется пара (i, j), для которых верно, что i <  j и a[i] > a[j]. Посчитайте количество инверсий за O(n log n).

## Быстрая сортировка [Quick sort]

Добавим сюда визуализацию кода, написанного выше:

![Quick sort](./img/quick_sort.gif)

Если хотите посмотреть, как работает пузырьковая сортировка на примере танца (вдруг), то [Quick-sort with Hungarian](https://youtu.be/ywWBy6J5gz8) вам поможет.

## Сортировка подсчётом [Count sort]

## По цифрам [Digit sort]
